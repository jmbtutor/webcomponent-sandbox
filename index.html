<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Web Components Test</title>

    <script src="node_modules/@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
    <script type="module" src="./hard-coded-list.js"></script>
    <script type="module" src="./single-slot.js"></script>
    <script type="module" src="./single-slot-with-default.js"></script>
    <script type="module" src="./with-attributes.js"></script>
    <script type="module" src="./outgoing-event.js"></script>
    <script type="module" src="./incoming-event.js"></script>
    <script type="module" src="./light-dom.js"></script>
    <style>
      output.event-output {
        display: block;
        max-height: 10em;
        overflow: auto;
      }
    </style>
  </head>
  <body>
    <h1>Web Components Test</h1>

    <!-- hard-coded-list -->
    <h2>hard-coded-list</h2>
    <!-- This experiment explores a Web Component with a set template. -->
    <hard-coded-list></hard-coded-list>

    <!-- single-slot -->
    <h2>single-slot</h2>
    <!-- The <single-slot> component contains a template with a single empty
         unnamed <slot>.
      -->

    <h3>empty</h3>
    <!-- This experiment explores the <single-slot> component with no child nodes.
         Result: no child nodes replace the <slot>.
      -->
    <single-slot></single-slot>

    <h3>text</h3>
    <!-- This experiment explores the <single-slot> component with a text child
         node in the light DOM.
         Result: the text node replaces the <slot>.
      -->
    <single-slot>innerHTML</single-slot>

    <h3>HTML</h3>
    <!-- This experiment explores the <single-slot> component with an HTML
         element child node in the light DOM.
         Result: the HTML element replaces the <slot>.
      -->
    <single-slot>
      <div>innerHTML div</div>
    </single-slot>

    <h3>Custom Element</h3>
    <!-- This experiment explores the <single-slot> component with a custom
         element as a child node in the light DOM.
         Result: the custom element replaces the <slot>.
      -->
    <single-slot>
      <hard-coded-list></hard-coded-list>
    </single-slot>

    <!-- single-slot-with-default -->
    <h2>single-slot-with-default</h2>
    <!-- The <single-slot-with-default> component contains a single unnamed
         slot with a text node as a default value.
      -->

    <h3>empty</h3>
    <!-- This experiment explores the <single-slot-with-default> component with no child nodes.
         Result: the default content of the <slot> is inserted.
      -->
    <single-slot-with-default></single-slot-with-default>

    <h3>whitespace</h3>
    <!-- This experiment explores the <single-slot-with-default> component with
         a single whitespace child node.
         Result: the whitespace node replaces the <slot>.
      -->
    <single-slot-with-default>
    </single-slot-with-default>

    <h3>text</h3>
    <!-- This experiment explores the <single-slot-with-default> component with a text node.
         Result: the text node replaces the <slot>.
      -->
    <single-slot-with-default>innerHTML</single-slot-with-default>

    <h3>HTML</h3>
    <!-- This experiment explores the <single-slot-with-default> component with an HTML element node.
         Result: the HTML element node replaces the <slot>.
      -->
    <single-slot-with-default>
      <div>innerHTML div</div>
    </single-slot-with-default>

    <h3>Custom Element</h3>
    <!-- This experiment explores the <single-slot-with-default> component with a custom element node.
         Result: the custom element node replaces the <slot>.
      -->
    <single-slot-with-default>
      <hard-coded-list></hard-coded-list>
    </single-slot-with-default>

    <!-- with-attributes -->
    <h2>with-attributes</h2>
    <!-- The <with-attributes> component is configurable through the "value"
         and "count" attributes. The text of both is displayed in its template.
         "value" is typed as a String, and "count" is typed as a Number.
      -->

    <h3>default</h3>
    <!-- This experiment explores the <with-attributes> component with no attrributes.
         Result: the initial values of the reflected properties are applied.
      -->
    <with-attributes></with-attributes>

    <h3>value</h3>
    <!-- This experiment explores the <with-attributes> component with the
         "value" attribute, where the value has some HTML in it.
         Result: the value of the "value" attribute is displayed verbatim.
      -->
    <with-attributes value="othervalue <br>"></with-attributes>

    <h3>count</h3>
    <!-- This experiment explores the <with-attributes> component with the
         "count" attribute, where the value is a number.
         Result: the value is displayed properly. The "value" attribute
         takes on its default value.
      -->
    <with-attributes count="5"></with-attributes>

    <h3>count (not number)</h3>
    <!-- This experiment explores the <with-attributes> component with the
         "count" attribute, where the value is not a number.
         Result: the value is coerced to NaN and is displayed as such. The
         "value" attribute takes on its default attribute.
      -->
    <with-attributes count="notnumber"></with-attributes>

    <h3>both</h3>
    <!-- This experiment explores the <with-attributes> component wth both
         the "value" and "count" attributes set.
         Result: both attributes take on the given values.
      -->
    <with-attributes value="othervalue" count="1"></with-attributes>

    <h3>setAttribute</h3>
    <!-- This experiment explores the <with-attributes> component and setting
         the attributes dynamically using JavaScript.
         Result: the attributes are set and coerced as expected.
      -->
    <label>value: <input oninput="document.getElementById('with-attributes-setattribute').setAttribute('value', this.value)" /></label>
    <label>count: <input oninput="document.getElementById('with-attributes-setattribute').setAttribute('count', this.value)" /></label>
    <with-attributes id="with-attributes-setattribute" value="othervalue" count="1"></with-attributes>

    <h3>set property</h3>
    <!-- This experiment explores the <with-attributes> component and setting
         its properties dynamically using JavaScript.
         Result: the values are used verbatim and not coerced.
      -->
    <label>value: <input oninput="document.getElementById('with-attributes-setproperty').value = this.value" /></label>
    <label>count: <input oninput="document.getElementById('with-attributes-setproperty').count = this.value" /></label>
    <with-attributes id="with-attributes-setproperty" value="othervalue" count="1"></with-attributes>

    <!-- outgoing-event -->
    <h2>outgoing-event</h2>
    <!-- The <outgoing-event> component contains an input box and a button.
         The "button-pressed" custom event is fired when the button is clicked.
      -->

    <h3>no listeners</h3>
    <!-- This experiment explores the <outgoing-event> component with no listeners.
         Result: No visible action.
      -->
    <outgoing-event></outgoing-event>

    <h3>addEventListener</h3>
    <!-- This experiment explores the <outgoing-event> component with a
         listener for the "button-pressed" custom event bound from the outside.
         Result: the listener is called.
      -->
    <outgoing-event id="outgoing-event-addEventListener"></outgoing-event><br />
    <output id="outgoing-event-addEventListener-output" class="event-output"></output>
    <script>
      document.getElementById('outgoing-event-addEventListener').addEventListener('button-pressed', (e) => document.getElementById('outgoing-event-addEventListener-output').innerHTML += `outgoing-event-addEventListener fired: ${e.type} ${JSON.stringify(e.detail)} ${event.target.tagName}<br />`);
    </script>

    <h3>attribute</h3>
    <!-- This experiment explores the <outgoing-event> component with an on-event attribute listener.
         Result: only native events can be captured.
      -->
    <outgoing-event id="outgoing-event-attribute" oninput="handleOutgoingEventAttributeInput(event)" onclick="handleOutgoingEventAttributeClick(event)"></outgoing-event><br />
    <output id="outgoing-event-attribute-output" class="event-output"></output>
    <script>
      function handleOutgoingEventAttributeInput(event) {
        document.getElementById('outgoing-event-attribute-output').innerHTML += `outgoing-event-attribute fired: ${event.type} ${JSON.stringify(event.detail)} ${event.target.tagName}<br />`;
      }

      function handleOutgoingEventAttributeClick(event) {
        document.getElementById('outgoing-event-attribute-output').innerHTML += `outgoing-event-attribute fired: ${event.type} ${JSON.stringify(event.detail)} ${event.target.tagName}<br />`;
      }
    </script>
    <!-- Must use <a href="https://github.com/Polymer/lit-element/issues/653">addEventListener</a> for custom events -->

    <!-- incoming-event -->
    <h2>incoming-event</h2>
    <!-- The <incoming-event> component listens for the "incoming-custom-event"
         custom event on the document and displays its details.
      -->

    <h3>with input</h3>
    <!-- This experiment explores the event handling of <incoming-event> by
         dispatching the "incoming-custom-event" custom event from an input box
         with the input box's contents as the event's details and letting it
         bubble up to the document.
         Result: the event is intercepted by the incoming-event element and its
         details are displayed.
      -->
    <incoming-event></incoming-event><br />
    <input oninput="handleIncomingEventInputInput.call(this, event)" />
    <script>
      function handleIncomingEventInputInput(event) {
        this.dispatchEvent(new CustomEvent('incoming-custom-event', { detail: this.value, bubbles: true, composed: true }))
      }
    </script>

    <!-- light-dom -->
    <h2>light-dom</h2>
    <!-- The <light-dom> component contains a single unnamed
         slot with a text node as a default value.
         The rendering is done in the light DOM.
      -->

    <h3>empty</h3>
    <!-- This experiment explores the <light-dom> component with no child nodes.
         Result: the entire template as defined by the component is rendered.
      -->
    <light-dom></light-dom>

    <h3>whitespace</h3>
    <!-- This experiment explores the <light-dom> component with
         a single whitespace child node.
         Result: the entire template as defined by the component is rendered.
      -->
    <light-dom>
    </light-dom>

    <h3>text</h3>
    <!-- This experiment explores the <light-dom> component with a text node.
         Result: the entire template as defined by the component is rendered,
         ignoring the text node.
      -->
    <light-dom>innerHTML</light-dom>

    <h3>HTML</h3>
    <!-- This experiment explores the <light-dom> component with an HTML element node.
         Result: the entire template as defined by the component is rendered,
         ignoring the HTML element node.
      -->
    <light-dom>
      <div>innerHTML div</div>
    </light-dom>

    <h3>Custom Element</h3>
    <!-- This experiment explores the <light-dom> component with a custom element node.
         Result: the entire template as defined by the component is rendered,
         ignoring the custom element.
      -->
    <light-dom>
      <hard-coded-list></hard-coded-list>
    </light-dom>
  </body>
</html>
